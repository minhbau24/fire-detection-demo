<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Detection System</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .camera-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .camera-container {
            position: relative;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .status.connected {
            background: #2ed573;
            color: white;
        }
        .status.error {
            background: #ff4757;
            color: white;
        }
        .spinner-border {
            width: 1.5rem;
            height: 1.5rem;
        }
    </style>
</head>
<body>
    <div class="container py-4">
        <h1 class="text-center mb-4">üî• Fire Detection System</h1>
        <div class="card mb-4">
            <div class="card-body">
                <div class="mb-3" id="camera-checkbox-list"></div>
                <div class="row g-2 align-items-center mb-2">
                    <div class="col-auto">
                        <input type="text" id="custom-url" class="form-control" placeholder="ho·∫∑c nh·∫≠p RTSP / HTTP link" />
                    </div>
                    <div class="col-auto">
                        <button onclick="startDetection()" id="start-btn" class="btn btn-primary">B·∫Øt ƒë·∫ßu ph√°t hi·ªán</button>
                    </div>
                    <div class="col-auto">
                        <button onclick="stopAllStreams()" id="stop-btn" class="btn btn-danger">D·ª´ng t·∫•t c·∫£</button>
                    </div>
                    <div class="col-auto" id="loading" style="display:none;">
                        <div class="spinner-border text-primary spinner-border" role="status"></div>
                        <span class="ms-2">ƒêang t√¨m camera...</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="camera-grid" id="camera-grid">
            <!-- Camera streams will be added here dynamically -->
        </div>
    </div>

    <script>
        let activeStreams = new Map(); // Track active camera streams
        let streamCounter = 0;

        // Show loading indicator
        function showLoading(message = "ƒêang t·∫£i...") {
            const loading = document.getElementById("loading");
            loading.querySelector("span").textContent = message;
            loading.style.display = "flex";
        }

        // Hide loading indicator
        function hideLoading() {
            document.getElementById("loading").style.display = "none";
        }

        // Load camera options with loading indicator and render checkboxes
        async function loadCameraOptions() {
            showLoading("ƒêang t√¨m camera...");
            const startBtn = document.getElementById("start-btn");
            startBtn.disabled = true;
            try {
                const res = await fetch("http://localhost:8000/list-cameras");
                const data = await res.json();
                const cameras = data.cameras || data;
                const checkboxList = document.getElementById("camera-checkbox-list");
                checkboxList.innerHTML = "";
                if (cameras.length === 0) {
                    checkboxList.innerHTML = '<span class="text-danger">Kh√¥ng t√¨m th·∫•y camera n√†o</span>';
                } else {
                    cameras.forEach(cam => {
                        const div = document.createElement("div");
                        div.className = "form-check form-check-inline mb-2";
                        div.innerHTML = `<input class='form-check-input camera-checkbox' type='checkbox' value='${cam.id}' id='cam${cam.id}'> <label class='form-check-label' for='cam${cam.id}'>${cam.name}${cam.resolution ? ` (${cam.resolution})` : ''}</label>`;
                        checkboxList.appendChild(div);
                    });
                }
            } catch (error) {
                console.error("Error loading cameras:", error);
                alert("L·ªói khi t·∫£i danh s√°ch camera: " + error.message);
            } finally {
                hideLoading();
                startBtn.disabled = false;
            }
        }

        // Start detection for selected cameras and custom URL
        function startDetection() {
            // L·∫•y c√°c camera ƒë√£ tick
            const checked = Array.from(document.querySelectorAll('.camera-checkbox:checked')).map(cb => cb.value);
            const customUrl = document.getElementById("custom-url").value;
            let added = 0;
            if (checked.length === 0 && !customUrl) {
                alert("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt camera ho·∫∑c nh·∫≠p URL!");
                return;
            }
            // Th√™m c√°c camera ƒë√£ tick
            checked.forEach(id => {
                if (!activeStreams.has(id)) {
                    addCameraStream(id);
                    added++;
                }
            });
            // Th√™m custom URL n·∫øu c√≥
            if (customUrl && !activeStreams.has(customUrl)) {
                addCameraStream(customUrl);
                added++;
            }
            if (added === 0) {
                alert("T·∫•t c·∫£ camera/URL ƒë√£ ƒë∆∞·ª£c b·∫≠t!");
            }
            // Clear input
            document.getElementById("custom-url").value = "";
        }

        // Add a new camera stream to the grid
        function addCameraStream(source) {
            streamCounter++;
            const streamId = `stream-${streamCounter}`;
            const cameraGrid = document.getElementById("camera-grid");
            
            const cameraContainer = document.createElement("div");
            cameraContainer.className = "camera-container";
            cameraContainer.id = streamId;
            
            const cameraName = isNaN(source) ? `URL Stream ${streamCounter}` : `Camera ${source}`;
            
            cameraContainer.innerHTML = `
                <button class="close-btn" onclick="stopStream('${streamId}', '${source}')" title="ƒê√≥ng camera n√†y">√ó</button>
                <div class="camera-label">${cameraName}</div>
                <img src="http://localhost:8000/video/${encodeURIComponent(source)}" 
                     alt="Camera Stream" 
                     onload="updateStatus('${streamId}', 'connected')"
                     onerror="updateStatus('${streamId}', 'error')">
                <div class="status" id="status-${streamId}">ƒêang k·∫øt n·ªëi...</div>
            `;
            
            cameraGrid.appendChild(cameraContainer);
            activeStreams.set(source, streamId);
        }

        // Update camera status
        function updateStatus(streamId, status) {
            const statusElement = document.getElementById(`status-${streamId}`);
            if (statusElement) {
                statusElement.className = `status ${status}`;
                if (status === 'connected') {
                    statusElement.textContent = "üü¢ ƒê√£ k·∫øt n·ªëi";
                } else if (status === 'error') {
                    statusElement.textContent = "üî¥ L·ªói k·∫øt n·ªëi";
                }
            }
        }

        // Stop a specific camera stream
        function stopStream(streamId, source) {
            const container = document.getElementById(streamId);
            if (container) {
                // X√≥a th·∫ª <img> ƒë·ªÉ ng·∫Øt k·∫øt n·ªëi HTTP stream
                const img = container.querySelector('img');
                if (img) {
                    img.src = '';
                }
                // Ch·ªß ƒë·ªông g·ªçi API backend ƒë·ªÉ gi·∫£i ph√≥ng camera ngay
                fetch(`http://localhost:8000/stop-stream/${encodeURIComponent(source)}`, { 
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    mode: 'cors'
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        console.log('Stop stream successful:', source);
                        return response.text();
                    })
                    .catch(err => {
                        console.warn('Kh√¥ng g·ªçi ƒë∆∞·ª£c API stop-stream:', err);
                        // Th·ª≠ g·ªçi l·∫°i v·ªõi GET (fallback)
                        fetch(`http://localhost:8000/stop-stream/${encodeURIComponent(source)}`, { method: 'GET' })
                            .catch(err2 => console.warn('GET fallback c≈©ng l·ªói:', err2));
                    });
                setTimeout(() => {
                    container.remove();
                }, 100); // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ browser ng·∫Øt k·∫øt n·ªëi
                activeStreams.delete(source);
            }
        }

        // Stop all camera streams
        function stopAllStreams() {
            if (activeStreams.size === 0) {
                alert("Kh√¥ng c√≥ camera n√†o ƒëang ho·∫°t ƒë·ªông!");
                return;
            }
            if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën d·ª´ng t·∫•t c·∫£ ${activeStreams.size} camera?`)) {
                // Ch·ªß ƒë·ªông g·ªçi API stop-stream cho t·∫•t c·∫£ camera ƒëang m·ªü
                for (const [source, streamId] of activeStreams.entries()) {
                    // X√≥a th·∫ª <img> ƒë·ªÉ ng·∫Øt k·∫øt n·ªëi HTTP stream
                    const container = document.getElementById(streamId);
                    if (container) {
                        const img = container.querySelector('img');
                        if (img) img.src = '';
                    }
                    fetch(`http://localhost:8000/stop-stream/${encodeURIComponent(source)}`, { 
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        mode: 'cors'
                    })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            console.log('Stop stream successful:', source);
                            return response.text();
                        })
                        .catch(err => {
                            console.warn('Kh√¥ng g·ªçi ƒë∆∞·ª£c API stop-stream:', err);
                            // Th·ª≠ g·ªçi l·∫°i v·ªõi GET (fallback)
                            fetch(`http://localhost:8000/stop-stream/${encodeURIComponent(source)}`, { method: 'GET' })
                                .catch(err2 => console.warn('GET fallback c≈©ng l·ªói:', err2));
                        });
                }
                const cameraGrid = document.getElementById("camera-grid");
                cameraGrid.innerHTML = "";
                activeStreams.clear();
                streamCounter = 0;
            }
        }

        // Load cameras when page loads
        window.onload = loadCameraOptions;

        // Allow Enter key to start detection
        document.getElementById("custom-url").addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                startDetection();
            }
        });

        // Refresh camera list periodically (every 30 seconds)
        // setInterval(loadCameraOptions, 30000);
    </script>
</body>
</html>
